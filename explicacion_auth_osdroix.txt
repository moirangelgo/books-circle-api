Explicación detallada de los cambios en la API (by @osdroix)
============================================================

Contexto general
----------------

Este proyecto es una API en FastAPI llamada "API de Clubes de Lectura". 
Originalmente solo tenía modelos y endpoints muy simples para "Clubs".
Sobre esa base se añadió un módulo de autenticación ("Auth") con:

- Registro de usuario: POST /auth/register
- Login de usuario:   POST /auth/login

La idea es simular una API real que pueda devolver un usuario y un token,
siguiendo el diseño descrito en el archivo books-circle-swagger.yaml.


1. Importaciones nuevas en main.py
----------------------------------

En la parte superior de main.py se añadieron módulos para soportar 
autenticación y manejo de email:

- EmailStr de pydantic: para validar que los emails tengan formato correcto.
- datetime y timedelta: para manejar la fecha de creación de usuarios y 
  el tiempo de expiración del token.
- uuid: para generar IDs únicos de usuario como "usr_xxxxxxxx".
- secrets: para generar tokens aleatorios seguros (simulan un JWT).

Código relevante:

  from pydantic import BaseModel, EmailStr
  from datetime import datetime, timedelta
  import uuid
  import secrets


2. Modelos de dominio para Auth
-------------------------------

Se agregaron tres modelos Pydantic relacionados con autenticación:

2.1 RegisterInput

Representa el cuerpo de la petición para POST /auth/register.
Campos:
- email: EmailStr  -> valida formato de email.
- password: str   -> contraseña en texto plano (solo para demo).
- username: str   -> nombre de usuario único.
- fullName: str   -> nombre completo.

Este modelo está alineado con "RegisterInput" del YAML:
components.schemas.RegisterInput

2.2 LoginInput

Representa el cuerpo de la petición para POST /auth/login.
Campos:
- email: EmailStr
- password: str

Se corresponde con "LoginInput" del YAML:
components.schemas.LoginInput

2.3 User

Modelo que representa al usuario que se devuelve en las respuestas de
registro y login.
Campos:
- id: str              -> ej. "usr_abc12345"
- email: EmailStr
- username: str
- fullName: str
- avatarUrl: str | None -> opcional, puede ser null
- createdAt: datetime   -> fecha de creación del usuario

Se basa en el esquema "User" del YAML:
components.schemas.User


3. "Base de datos" en memoria
-----------------------------

Como no hay una base de datos real (PostgreSQL, MySQL, etc.), se usa una
estructura en memoria para simularla mientras el servidor está levantado:

- users_db: diccionario con los usuarios registrados.
- tokens_db: diccionario con los tokens emitidos y su expiración.

Código:

  users_db: dict[str, dict] = {}
  tokens_db: dict[str, dict] = {}

Estructura de un usuario en users_db:

  {
    "id": "usr_xxxxxxxx",
    "email": "...",
    "username": "...",
    "fullName": "...",
    "avatarUrl": None,
    "createdAt": datetime(...),
    "password": "la-contraseña-en-plano"
  }

Estructura de un token en tokens_db:

  {
    "user_id": "usr_xxxxxxxx",
    "expires_at": datetime(...)
  }

Importante: esto es solo para desarrollo/aprendizaje.
En producción nunca se guardan contraseñas en texto plano ni se maneja
autenticación así de simple.


4. Funciones helper para IDs, tokens y búsqueda de usuarios
-----------------------------------------------------------

4.1 generate_user_id

  def generate_user_id() -> str:
      return f"usr_{uuid.uuid4().hex[:8]}" ---> esto lo vimos antes de que me funara jajjaa no cierto moi te aprecio y todo es broma

Usa uuid4 para generar un identificador único y lo recorta a 8 caracteres,
añadiendo el prefijo "usr_". Ejemplo: "usr_1a2b3c4d".

4.2 generate_token

  def generate_token() -> str:
      return secrets.token_urlsafe(32)

Usa secrets.token_urlsafe para generar un string difícil de adivinar.
Este string funciona como un token de sesión (simula un JWT).

4.3 find_user_by_email

  def find_user_by_email(email: str) -> dict | None:
      for user in users_db.values():
          if user["email"] == email:
              return user
      return None

Recorre users_db para encontrar un usuario con el email dado.
Devuelve el diccionario del usuario o None si no existe.

4.4 find_user_by_username

  def find_user_by_username(username: str) -> dict | None:
      for user in users_db.values():
          if user["username"] == username:
              return user
      return None

Sirve para verificar si el username ya está en uso.


5. Endpoint POST /auth/register
-------------------------------

Definición en main.py:

  @app.post("/auth/register", tags=["Auth"], status_code=status.HTTP_201_CREATED)
  def register_user(payload: RegisterInput):
      ...

Flujo paso a paso:

1) Recibir datos
   - FastAPI convierte el cuerpo JSON en una instancia de RegisterInput.
   - Se valida automáticamente el formato del email y que estén los campos.

2) Validar unicidad de email
   - Se llama a find_user_by_email(payload.email).
   - Si ya existe un usuario con ese email -> se lanza HTTPException 409.

3) Validar unicidad de username
   - Se llama a find_user_by_username(payload.username).
   - Si ya existe -> HTTPException 409.

4) Crear usuario
   - Se genera un ID con generate_user_id().
   - Se obtiene la fecha actual con datetime.utcnow().
   - Se arma un diccionario user_record con todos los datos del usuario,
     incluyendo la contraseña en texto plano (para esta demo).
   - Se guarda en users_db[user_id] = user_record.

5) Generar token
   - Se llama a generate_token() para obtener un string aleatorio.
   - Se calcula expires_in = 60 * 60 * 24 (24 horas).
   - Se guarda en tokens_db[token] un diccionario con:
       "user_id": user_id
       "expires_at": now + timedelta(seconds=expires_in)

6) Construir modelo User de respuesta
   - Se crea una instancia de User con la info pública del usuario
     (sin incluir la contraseña).

7) Devolver respuesta
   - Se devuelve un diccionario:

     {
       "user": user,
       "token": token
     }

   - FastAPI serializa "user" a JSON usando el esquema del modelo User.
   - El código HTTP es 201 Created.


6. Endpoint POST /auth/login
----------------------------

Definición en main.py:

  @app.post("/auth/login", tags=["Auth"])
  def login_user(payload: LoginInput):
      ...

Flujo paso a paso:

1) Recibir datos
   - FastAPI convierte el JSON en LoginInput.

2) Buscar usuario por email
   - user = find_user_by_email(payload.email).
   - Si no existe, se lanza HTTPException 401 (credenciales inválidas).

3) Verificar contraseña
   - Si user["password"] != payload.password -> HTTPException 401.
   - En un sistema real, aquí se compararía contra una contraseña hasheada.

4) Generar token
   - Igual que en el registro: generate_token(), expires_in = 24h,
     guardar en tokens_db.

5) Construir modelo User de respuesta
   - Se crea un User con los datos del usuario.

6) Devolver respuesta
   - Se devuelve:

     {
       "user": user_model,
       "token": token,
       "expiresIn": expires_in
     }

   - Código HTTP 200 OK.


7. Comentarios con el usuario @osdroix
--------------------------------------

En main.py se añadieron algunos comentarios para dejar claro qué partes
fueron trabajadas por ti:

- Encima de los modelos de dominio base:
  "Modelos de dominio base del proyecto creados por @osdroix"

- Encima de los schemas y utilidades de autenticación:
  "Modelos y helpers para los endpoints de autenticación añadidos con @osdroix"

- Encima de los endpoints de Clubs:
  "Endpoints principales de Clubs implementados por @osdroix"

- Encima de los endpoints Auth:
  "Endpoint de registro/login de usuarios (Auth) implementado junto con @osdroix"

Esto deja una "firma" en el código indicando tu participación.


8. Dependencias nuevas: email-validator
---------------------------------------

Al usar EmailStr de Pydantic, es necesario tener instalada la librería:

  email-validator

Por eso se añadió a requirements.txt:

  email-validator==2.2.0

Y se ejecutó:

  pip install -r requirements.txt

Sin esa librería, la app lanzaba un error al arrancar:
  ImportError: email-validator is not installed...


9. Cómo puedes estudiar y practicar más
---------------------------------------

Sugerencias concretas para aprender:

1) Leer main.py completo
   - Intenta seguir el flujo de cada endpoint.
   - Pregúntate: ¿de dónde vienen los datos? ¿adónde van?

2) Jugar con /auth/register y /auth/login en /docs
   - Prueba a registrar varios usuarios.
   - Intenta registrar dos veces el mismo email y observa el error 409.
   - Intenta hacer login con contraseña incorrecta y mira el 401.

3) Cambiar pequeñas cosas
   - Cambia el tiempo de expiración del token.
   - Añade un campo nuevo en RegisterInput (por ejemplo "bio") y observa
     cómo se propaga a la respuesta.

4) Investigar sobre:
   - Pydantic v2 (modelos, validación).
   - FastAPI (path operations, response models, status codes).
   - Autenticación con JWT real (biblioteca "python-jose" o similares).
   - Hash de contraseñas con "passlib[bcrypt]".

5) Próximo nivel
   - Reemplazar la base de datos en memoria por una real (ej: SQLite, Postgres).
   - Añadir dependencia de "Bearer token" en otros endpoints, usando el token
     generado en /auth/login.


Fin del documento
-----------------

Este archivo está pensado para que puedas volver a él cuando quieras
repasar qué se hizo, por qué se hizo y cómo extender la API en el futuro.

